---
import BaseLayout from '../../layouts/BaseLayout.astro';
import { SITE_TITLE } from '../../consts';
import DatePicker from '../../components/DatePicker.astro';
import NewsCard from '../../components/NewsCard.astro';
import { getAllArticles, getAllCategories } from '../../utils/contentApi.js';

// Configuración para SSR
export const prerender = false;

// Configuración de paginación
const ITEMS_PER_PAGE = 10;

// Obtener el número de página actual de los parámetros de URL
const url = new URL(Astro.request.url);
const currentPage = url.searchParams.get('page') || '1';
const pageNumber = parseInt(currentPage) || 1;

// Definir un tipo para la respuesta de la API
interface ArticleResponse {
  articles: Array<{
    slug: string;
    title: string;
    description: string;
    content: string;
    pubDate?: string;
    pub_date?: string;
    date?: string;
    category?: string;
    featured_image?: string;
    image?: string;
    author?: string;
  }>;
  pagination: {
    page: number;
    pageSize: number;
    totalItems: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
}

// Obtener todas las noticias desde la API con paginación
const response = await getAllArticles(Astro.url.origin, pageNumber, ITEMS_PER_PAGE) as ArticleResponse;

// Obtener todas las categorías para el filtro
const categories = await getAllCategories(Astro.url.origin);

// Desestructurar la respuesta para obtener artículos y datos de paginación
// Definir un tipo para los artículos
interface Article {
  slug: string;
  title: string;
  description: string;
  content: string;
  pubDate?: string;
  pub_date?: string;
  date?: string;
  category?: string;
  featured_image?: string;
  image?: string;
  author?: string;
}

// Extraer los datos de la respuesta con tipado
const articles = response.articles || [];
const pagination = response.pagination || {
  page: 1,
  pageSize: ITEMS_PER_PAGE,
  totalItems: 0,
  totalPages: 0,
  hasNextPage: false,
  hasPrevPage: false
};

// Función para normalizar imágenes
const normalizeImage = (imagePath: string | undefined): string => {
  // Si no hay imagen o la ruta está causando 404
  if (!imagePath || imagePath.startsWith('media/uploads/') || 
      imagePath.includes('+') || imagePath.includes('%25')) {
    // Usar la imagen del Colectivo (logo sin fondo)
    return '/images/CAAY Logo sin fondo.png';
  }
  return imagePath;
};

// Configurar variables de paginación desde la respuesta de la API
const { page, totalPages, hasNextPage, hasPrevPage } = pagination;

// Título y descripción de la página
const pageTitle = `Noticias - ${SITE_TITLE}`;
const pageDescription = "Archivo de noticias del Colectivo Agrario Abya Yala.";

// Inicializar las variables de filtro
const initialCategory = "";
const initialDateFrom = null;
const initialDateTo = null;
const initialSearchTerm = "";

// No necesitamos hacer slicing manualmente ya que la API ya nos devuelve los artículos paginados
// Preparar URLs para navegación
const previousPage = pagination.hasPrevPage ? `?page=${pagination.page - 1}` : null;
const nextPage = pagination.hasNextPage ? `?page=${pagination.page + 1}` : null;

---

<BaseLayout title={pageTitle} description={pageDescription}>
  <main class="news-archive">
    <div class="container">
      <div class="page-header">
        <h1>Archivo de Noticias</h1>
        <p class="lead">Explora todas nuestras noticias, desde las más recientes hasta las más antiguas.</p>
      </div>

      <div class="filters-container">
        <div class="search-container">
          <input
            type="text"
            id="search-input"
            class="search-input"
            placeholder="Buscar noticias..."
          />
          <button id="search-button" class="search-button">
            <i class="ri-search-line"></i>
          </button>
        </div>

        <div class="filter-group">
          <label for="category-filter">Categoría:</label>
          <select id="category-filter" class="filter-select">
            <option value="">Todas las categorías</option>
            {categories.map(category => (
              <option value={category.id}>{category.name}</option>
            ))}
          </select>
        </div>

        <div class="filter-row">
          <div class="filter-group date-filter">
            <label for="date-from">Desde:</label>
            <DatePicker id="date-from" />
          </div>

          <div class="filter-group date-filter">
            <label for="date-to">Hasta:</label>
            <DatePicker id="date-to" />
          </div>

          <button id="clear-filters" class="clear-filters">
            Limpiar filtros
          </button>
        </div>
      </div>

      <div class="active-filters" id="active-filters"></div>
      
      <div class="news-grid" id="news-grid">
        {articles && articles.length > 0 ? articles.map((article: Article) => {
          // Estandarización de campos
          const title = article.title || 'Sin título';
          
          // Recortar la descripción a un máximo de 150 caracteres
          let description = article.description || '';
          if (description.length > 150) {
            description = description.substring(0, 147) + '...';
          }
          
          // Manejar diferentes formatos de fecha
          const pubDate = article.pubDate || article.pub_date || article.date || new Date();
          
          // Manejar diferentes formatos de categoría
          const category = article.category || '';
          
          // Manejar diferentes formatos de imagen
          const image = normalizeImage(article.featured_image || article.image || '');
          
          return (
            <div class="news-item" 
              data-title={title.toLowerCase()}
              data-date={new Date(pubDate).toISOString()}
            >
              <NewsCard 
                title={title}
                description={description}
                pubDate={pubDate}
                category={category || ''}
                image={image}
                slug={article.slug || ''}
              />
            </div>
          );
        }) : (
          <div class="no-results">
            <p>No se encontraron noticias. Por favor, inténtelo de nuevo más tarde.</p>
          </div>
        )}
      </div>

      {pagination.totalPages > 0 && (
        <div class="pagination">
          <a 
            href={previousPage} 
            class="pagination-link prev" 
            class:list={{ disabled: !previousPage }}
          >
            <i class="ri-arrow-left-line"></i> Página anterior
          </a>
          <span class="pagination-info">Página {pagination.page} de {pagination.totalPages}</span>
          
          <a 
            href={nextPage} 
            class="pagination-btn next-page" 
            aria-label="Página siguiente"
            style={!nextPage ? "opacity: 0.5; pointer-events: none;" : ""}
          >
            Siguiente
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" aria-hidden="true">
              <polyline points="9 18 15 12 9 6"></polyline>
            </svg>
          </a>
        </div>
      )}
    </div>
    </div>
  </main>
</BaseLayout>

<style>
  .container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 1rem;
  }
  
  .page-header {
    margin: 2rem 0;
    text-align: center;
  }
  
  .page-header h1 {
    font-size: 2.5rem;
    margin-bottom: 0.5rem;
    color: var(--color-heading);
  }
  
  .page-header .lead {
    font-size: 1.1rem;
    color: var(--color-text-muted);
    max-width: 700px;
    margin: 0 auto;
  }
  
  .filters-section {
    margin: 2rem 0;
    padding: 1.5rem;
    background-color: var(--color-card-bg);
    border-radius: 8px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
  }
  
  .search-filter {
    margin-bottom: 1rem;
  }
  
  .search-input-wrapper {
    position: relative;
    display: flex;
    align-items: center;
  }
  
  .search-input-wrapper input {
    width: 100%;
    padding: 0.75rem 1rem;
    padding-right: 3rem;
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    font-size: 1rem;
    transition: all 0.2s ease;
  }
  
  .search-input-wrapper input:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(var(--color-primary-rgb, 0, 102, 204), 0.15);
  }
  
  .search-button {
    position: absolute;
    right: 0.75rem;
    top: 50%;
    transform: translateY(-50%);
    background: none;
    border: none;
    color: var(--color-text-muted);
    cursor: pointer;
    transition: color 0.2s ease;
  }
  
  .search-button:hover {
    color: var(--color-primary);
  }
  
  .category-filter {
    margin-bottom: 1rem;
  }
  
  .category-filter select {
    width: 100%;
    padding: 0.75rem 1rem;
    border: 1px solid var(--color-border);
    border-radius: 0.375rem;
    font-size: 1rem;
    background-color: #fff;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  
  .category-filter select:focus {
    outline: none;
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(var(--color-primary-rgb, 0, 102, 204), 0.15);
  }
  
  .date-filter {
    display: flex;
    gap: 1rem;
  }
  
  .date-from, .date-to {
    flex: 1;
  }
  
  .clear-filters-btn {
    padding: 0.75rem 1rem;
    background-color: var(--color-secondary-light);
    color: var(--color-secondary-dark);
    border: none;
    border-radius: 0.375rem;
    font-size: 0.9rem;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    white-space: nowrap;
  }
  
  .clear-filters-btn:hover {
    background-color: var(--color-secondary-light-hover);
  }
  
  .active-filters {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    margin-bottom: 1.5rem;
  }
  
  .news-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 1.5rem;
    margin-bottom: 2rem;
  }

  .news-item {
    display: flex;
    height: 100%;
    transition: transform 0.3s, box-shadow 0.3s;
  }

  .news-item:hover {
    transform: translateY(-5px);
  }

  /* Estilos para tarjetas consistentes */
  .news-item :global(.news-card) {
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  
  /* Asegurar que todas las imágenes tienen la misma proporción */
  .news-item :global(.image-container) {
    aspect-ratio: 16 / 9;
  }

  @media (max-width: 768px) {
    .news-grid {
      grid-template-columns: 1fr;
    }
  }
  
  .read-more {
    display: inline-block;
    color: var(--color-primary);
    font-weight: 600;
    text-decoration: none;
    transition: all 0.2s ease;
  }
  
  .read-more:hover {
    color: var(--color-primary-dark);
    text-decoration: underline;
  }
  
  .no-results {
    text-align: center;
    padding: 3rem 0;
  }
  
  .no-results-content {
    max-width: 500px;
    margin: 0 auto;
  }
  
  .no-results-content svg {
    color: var(--color-text-muted);
    margin-bottom: 1.5rem;
  }
  
  .no-results-content h3 {
    font-size: 1.8rem;
    margin-bottom: 1rem;
    color: var(--color-heading);
  }
  
  .no-results-content p {
    color: var(--color-text-muted);
    line-height: 1.6;
    margin-bottom: 1.5rem;
  }
  
  .pagination {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 1rem;
    margin-top: 2rem;
    margin-bottom: 3rem;
  }
  
  .pagination-btn {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    padding: 0.75rem 1rem;
    border: 1px solid var(--color-border);
    border-radius: 4px;
    background-color: white;
    color: var(--color-text);
    font-weight: 500;
    text-decoration: none;
    transition: all 0.2s ease;
  }
  
  .pagination-btn:hover {
    background-color: var(--color-primary);
    color: white;
    border-color: var(--color-primary);
  }
  
  .pagination-info {
    font-weight: 500;
    color: var(--color-text-muted);
  }
  
@media (max-width: 992px) {
    .news-grid {
      grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    }
  }
  
@media (max-width: 768px) {
    .page-header h1 {
      font-size: 2rem;
    }
    
    .filters-section {
      padding: 1rem;
    }
    
    .news-content {
      padding: 1.25rem;
    }
    
    .news-title {
      font-size: 1.25rem;
    }
    
    .pagination {
      flex-wrap: wrap;
    }
  }
  
  @media (max-width: 576px) {
    .page-header h1 {
      font-size: 1.8rem;
    }
    
    .news-grid {
      grid-template-columns: 1fr;
    }
  }
</style>

<script>
  // Funcionalidad de filtrado y ordenación
  document.addEventListener('DOMContentLoaded', () => {
    const sortSelect = document.getElementById('category-filter') as HTMLSelectElement;
    const searchInput = document.getElementById('search-input') as HTMLInputElement;
    const searchBtn = document.getElementById('search-button');
    const dateFromInput = document.getElementById('date-from') as HTMLInputElement;
    const dateToInput = document.getElementById('date-to') as HTMLInputElement;
    const clearFiltersBtn = document.getElementById('clear-filters');
    const newsGrid = document.getElementById('news-grid');
    const activeFilters = document.getElementById('active-filters');
    
    if (!newsGrid || !searchInput || !searchBtn) return;
    
    // Obtener todos los elementos de noticias
    const newsItems = document.querySelectorAll('.news-item');
    
    // Función para filtrar y ordenar los elementos
    const filterAndSortItems = () => {
      const searchTerm = searchInput.value.toLowerCase().trim();
      const selectedCategory = sortSelect?.value || '';
      const dateFrom = dateFromInput?.value ? new Date(dateFromInput.value) : null;
      const dateTo = dateToInput?.value ? new Date(dateToInput.value) : null;
      
      // Crear un array de los elementos para ordenar
      const itemsArray = Array.from(newsItems);
      
      // Filtrar por término de búsqueda, categoría y fechas
      let filteredItems = itemsArray.filter(item => {
        const title = (item as HTMLElement).dataset.title || '';
        const category = (item as HTMLElement).dataset.category || '';
        const dateStr = (item as HTMLElement).dataset.date;
        let passesFilter = true;
        
        // Filtrar por término de búsqueda
        if (searchTerm && !title.includes(searchTerm)) {
          passesFilter = false;
        }
        
        // Filtrar por categoría
        if (selectedCategory && category !== selectedCategory) {
          passesFilter = false;
        }
        
        // Filtrar por fecha
        if (dateStr) {
          const itemDate = new Date(dateStr);
          
          if (dateFrom && itemDate < dateFrom) {
            passesFilter = false;
          }
          
          if (dateTo) {
            // Ajustar la fecha final para incluir todo el día
            const adjustedDateTo = new Date(dateTo);
            adjustedDateTo.setHours(23, 59, 59, 999);
            
            if (itemDate > adjustedDateTo) {
              passesFilter = false;
            }
          }
        }
        
        return passesFilter;
      });
      
      // Ocultar todos los elementos
      itemsArray.forEach(item => {
        (item as HTMLElement).style.display = 'none';
      });
      
      // Mostrar los elementos filtrados
      if (filteredItems.length > 0) {
        filteredItems.forEach(item => {
          (item as HTMLElement).style.display = '';
        });
        
        // Eliminar mensaje de no resultados si existe
        const noResultsEl = document.querySelector('.no-results');
        if (noResultsEl) {
          noResultsEl.remove();
        }
      } else {
        // Mostrar mensaje si no hay resultados
        if (!document.querySelector('.no-results')) {
          const noResults = document.createElement('div');
          noResults.className = 'no-results';
          noResults.innerHTML = '<p>No se encontraron noticias con los criterios seleccionados.</p>';
          if (newsGrid.parentNode) {
            newsGrid.parentNode.insertBefore(noResults, newsGrid.nextSibling);
          }
        }
      }
      
      // Actualizar filtros activos
      updateActiveFilters();
    };
    
    // Función para actualizar los filtros activos
    const updateActiveFilters = () => {
      if (!activeFilters) return;
      
      activeFilters.innerHTML = '';
      
      const searchTerm = searchInput.value.trim();
      const selectedCategory = sortSelect?.value || '';
      const dateFrom = dateFromInput?.value || '';
      const dateTo = dateToInput?.value || '';
      
      if (searchTerm) {
        addActiveFilter(`Búsqueda: ${searchTerm}`);
      }
      
      if (selectedCategory) {
        const categoryOption = sortSelect.options[sortSelect.selectedIndex];
        addActiveFilter(`Categoría: ${categoryOption.textContent}`);
      }
      
      if (dateFrom) {
        addActiveFilter(`Desde: ${new Date(dateFrom).toLocaleDateString()}`);
      }
      
      if (dateTo) {
        addActiveFilter(`Hasta: ${new Date(dateTo).toLocaleDateString()}`);
      }
    };
    
    // Función para añadir un filtro activo
    const addActiveFilter = (text: string) => {
      const filter = document.createElement('span');
      filter.className = 'active-filter';
      filter.textContent = text;
      activeFilters?.appendChild(filter);
    };
    
    // Evento para buscar al hacer clic en el botón
    searchBtn?.addEventListener('click', filterAndSortItems);
    
    // Evento para buscar al presionar Enter en el campo de búsqueda
    searchInput?.addEventListener('keyup', (e) => {
      if (e.key === 'Enter') {
        filterAndSortItems();
      }
    });
    
    // Eventos para filtrar por categoría
    sortSelect?.addEventListener('change', filterAndSortItems);
    
    // Eventos para filtrar por fecha
    dateFromInput?.addEventListener('change', filterAndSortItems);
    dateToInput?.addEventListener('change', filterAndSortItems);
    
    // Evento para limpiar filtros
    clearFiltersBtn?.addEventListener('click', () => {
      if (searchInput) searchInput.value = '';
      if (sortSelect) sortSelect.selectedIndex = 0;
      if (dateFromInput) dateFromInput.value = '';
      if (dateToInput) dateToInput.value = '';
      filterAndSortItems();
    });
  });
</script>

<script>
  import DatePicker from '../../scripts/datePicker.js';
  
  document.addEventListener('DOMContentLoaded', () => {
    // Inicializar selectores de fecha
    const dateFromPicker = new DatePicker('date-from');
    const dateToPicker = new DatePicker('date-to');
    
    // Elementos del DOM
    const searchInput = document.getElementById('search-input') as HTMLInputElement;
    const categoryFilter = document.getElementById('category-select') as HTMLSelectElement;
    const clearFiltersBtn = document.getElementById('clear-filters') as HTMLButtonElement;
    const newsItems = document.querySelectorAll('.news-card');
    const noResultsElement = document.querySelector('.no-results') as HTMLElement;
    const activeFiltersElement = document.getElementById('active-filters');
    
    // Variables para paginación
    const itemsPerPage = 9;
    let currentPage = 1;
    let filteredItems = Array.from(newsItems);
    
    // Elementos de paginación
    const prevButton = document.querySelector('.pagination-prev') as HTMLButtonElement;
    const nextButton = document.querySelector('.pagination-next') as HTMLButtonElement;
    const currentPageElement = document.querySelector('.current-page');
    const totalPagesElement = document.querySelector('.total-pages');
    
    // Función para aplicar todos los filtros
    function applyFilters() {
      const searchTerm = searchInput.value.toLowerCase().trim();
      const selectedCategory = categoryFilter.value;
      const dateFrom = dateFromPicker.getSelectedDate();
      const dateTo = dateToPicker.getSelectedDate();
      
      // Actualizar filtros activos
      updateActiveFilters(searchTerm, selectedCategory, dateFrom, dateTo);
      
      // Filtrar elementos
      filteredItems = Array.from(newsItems).filter(item => {
        const title = item.querySelector('.news-title')?.textContent?.toLowerCase() || '';
        const description = item.querySelector('.news-excerpt')?.textContent?.toLowerCase() || '';
        const category = (item as HTMLElement).dataset.category?.toLowerCase() || '';
        const dateStr = (item as HTMLElement).dataset.date || '';
        const itemDate = dateStr ? new Date(dateStr) : null;
        
        // Filtrar por término de búsqueda
        const matchesSearch = !searchTerm || 
          title.includes(searchTerm) || 
          description.includes(searchTerm) || 
          category.includes(searchTerm);
        
        // Filtrar por categoría
        const matchesCategory = selectedCategory === '' || 
          category === selectedCategory.toLowerCase();
        
        // Filtrar por rango de fechas
        let matchesDateRange = true;
        if (itemDate) {
          if (dateFrom && dateTo) {
            matchesDateRange = itemDate >= dateFrom && itemDate <= dateTo;
          } else if (dateFrom) {
            matchesDateRange = itemDate >= dateFrom;
          } else if (dateTo) {
            matchesDateRange = itemDate <= dateTo;
          }
        }
        
        return matchesSearch && matchesCategory && matchesDateRange;
      });
      
      // Actualizar la UI
      updateUI();
    }
    
    // Función para actualizar la UI después de filtrar
    function updateUI() {
      // Ocultar todos los elementos
      newsItems.forEach(item => {
        (item as HTMLElement).style.display = 'none';
      });
      
      // Calcular paginación
      const totalPages = Math.ceil(filteredItems.length / itemsPerPage);
      if (currentPage > totalPages) {
        currentPage = totalPages || 1;
      }
      
      // Actualizar elementos de paginación
      if (currentPageElement) currentPageElement.textContent = currentPage.toString();
      if (totalPagesElement) totalPagesElement.textContent = totalPages.toString();
      
      // Habilitar/deshabilitar botones de paginación
      if (prevButton) prevButton.disabled = currentPage <= 1;
      if (nextButton) nextButton.disabled = currentPage >= totalPages;
      
      // Mostrar elementos de la página actual
      const startIndex = (currentPage - 1) * itemsPerPage;
      const endIndex = Math.min(startIndex + itemsPerPage, filteredItems.length);
      
      for (let i = startIndex; i < endIndex; i++) {
        (filteredItems[i] as HTMLElement).style.display = '';
      }
      
      // Mostrar mensaje de no resultados si es necesario
      if (noResultsElement) {
        noResultsElement.style.display = filteredItems.length === 0 ? 'block' : 'none';
      }
    }
    
    // Función para actualizar los filtros activos
    function updateActiveFilters(searchTerm: string, category: string, dateFrom: Date | null, dateTo: Date | null) {
      if (!activeFiltersElement) return;
      
      activeFiltersElement.innerHTML = '';
      
      // Añadir filtro de búsqueda
      if (searchTerm) {
        addActiveFilter('Búsqueda', searchTerm, () => {
          searchInput.value = '';
          applyFilters();
        });
      }
      
      // Añadir filtro de categoría
      if (category && category !== '') {
        const categoryText = categoryFilter.options[categoryFilter.selectedIndex].text;
        addActiveFilter('Categoría', categoryText, () => {
          categoryFilter.value = '';
          applyFilters();
        });
      }
      
      // Añadir filtro de fecha desde
      if (dateFrom) {
        const formattedDate = formatDate(dateFrom);
        addActiveFilter('Desde', formattedDate, () => {
          dateFromPicker.clearDate();
          applyFilters();
        });
      }
      
      // Añadir filtro de fecha hasta
      if (dateTo) {
        const formattedDate = formatDate(dateTo);
        addActiveFilter('Hasta', formattedDate, () => {
          dateToPicker.clearDate();
          applyFilters();
        });
      }
    }
    
    // Función para añadir un filtro activo
    function addActiveFilter(label: string, value: string, removeCallback: () => void) {
      const filterElement = document.createElement('div');
      filterElement.className = 'active-filter';
      filterElement.innerHTML = `
        <span>${label}: ${value}</span>
        <button type="button" aria-label="Eliminar filtro">
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <line x1="18" y1="6" x2="6" y2="18"></line>
            <line x1="6" y1="6" x2="18" y2="18"></line>
          </svg>
        </button>
      `;
      
      const removeButton = filterElement.querySelector('button');
      if (removeButton) {
        removeButton.addEventListener('click', removeCallback);
      }
      
      activeFiltersElement?.appendChild(filterElement);
    }
    
    // Función para formatear fecha
    function formatDate(date: Date): string {
      const day = date.getDate().toString().padStart(2, '0');
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${day}/${month}/${year}`;
    }
    
    // Función para limpiar todos los filtros
    function clearAllFilters() {
      searchInput.value = '';
      categoryFilter.value = '';
      dateFromPicker.clearDate();
      dateToPicker.clearDate();
      currentPage = 1;
      applyFilters();
    }
    
    // Eventos
    if (searchInput) {
      searchInput.addEventListener('input', () => {
        currentPage = 1;
        applyFilters();
      });
    }
    
    if (categoryFilter) {
      categoryFilter.addEventListener('change', () => {
        currentPage = 1;
        applyFilters();
      });
    }
    
    // Manejar el botón principal de limpiar filtros
    if (clearFiltersBtn) {
      clearFiltersBtn.addEventListener('click', clearAllFilters);
    }
    
    // Manejar todos los botones con clase clear-filters-btn
    document.querySelectorAll('.clear-filters-btn').forEach(button => {
      button.addEventListener('click', clearAllFilters);
    });
    
    // Eventos de fecha - usando un enfoque más robusto
    const dateFromInput = document.getElementById('date-from');
    if (dateFromInput) {
      dateFromInput.addEventListener('change', () => {
        currentPage = 1;
        applyFilters();
      });
    }
    
    const dateToInput = document.getElementById('date-to');
    if (dateToInput) {
      dateToInput.addEventListener('change', () => {
        currentPage = 1;
        applyFilters();
      });
    }
    
    // También escuchar eventos en los contenedores de fecha por si el componente DatePicker emite eventos personalizados
    document.querySelector('.date-from')?.addEventListener('dateSelected', () => {
      currentPage = 1;
      applyFilters();
    });
    
    document.querySelector('.date-to')?.addEventListener('dateSelected', () => {
      currentPage = 1;
      applyFilters();
    });
    
    // Eventos de paginación
    if (prevButton) {
      prevButton.addEventListener('click', () => {
        if (currentPage > 1) {
          currentPage--;
          updateUI();
        }
      });
    }
    
    if (nextButton) {
      nextButton.addEventListener('click', () => {
        const totalPages = Math.ceil(filteredItems.length / itemsPerPage);
        if (currentPage < totalPages) {
          currentPage++;
          updateUI();
        }
      });
    }
    
    // Inicializar la UI
    applyFilters();
  });
</script>
