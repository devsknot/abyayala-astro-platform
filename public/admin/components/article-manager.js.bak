// Gestor de artículos para el CMS
import { ContentManager } from '../content-manager.js';
import { ContentEditor } from './editor.js';
import { MediaLibrary } from './media-library.js';
import { MediaManager } from '../media-manager.js';
import { notifications } from './notification.js';

export class ArticleManager {
  constructor(container, options = {}) {
    try {
      // Si se pasa un contenedor directamente, usar el modo antiguo
      if (container && typeof container === 'object' && container.nodeType === 1) {
        this.container = container;
        this.contentManager = new ContentManager();
        this.mediaManager = new MediaManager();
        this.notificationManager = notifications;
      } else {
        // Modo nuevo: se pasan los managers como parámetros
        this.contentManager = options.contentManager || new ContentManager();
        this.mediaManager = options.mediaManager || new MediaManager();
        this.notificationManager = options.notificationManager || notifications;
        this.container = null;
      }
      
      this.articlesContainer = null;
      this.editor = null;
      this.currentArticle = null;
      
      // Configuración de paginación
      this.pagination = {
        page: 1,
        limit: 10,
        total: 0,
        totalPages: 1
      };
      
      // Configuración de filtros
      this.filters = {
        search: '',
        category: '',
        sortBy: 'pubDate',
        sortOrder: 'desc'
      };
      
      // Inicializar si tenemos un contenedor
      if (this.container) {
        this.init();
      }
    } catch (error) {
      console.error('Error en el constructor de ArticleManager:', error);
    }
  }
  
  // Método de inicialización
  init() {
    try {
      // Crear la estructura del gestor de artículos si no existe
      if (!this.container.querySelector('.article-manager')) {
        // Usar el método render para inicializar la interfaz
        this.render(this.container);
      } else {
        // Si ya existe la estructura, obtener referencias a los elementos
        this.articlesList = this.container.querySelector('.articles-list');
        this.articlesContainer = this.container.querySelector('.articles-container');
        this.articleEditor = this.container.querySelector('.article-editor');
        this.articleForm = this.container.querySelector('.article-form');
        this.editorContainer = this.container.querySelector('#article-content-editor');
        this.featuredImagePreview = this.container.querySelector('.featured-image-preview');
        this.featuredImageInput = this.container.querySelector('#article-image');
        this.galleryGrid = this.container.querySelector('.gallery-grid');
        
        // Configurar eventos
        this.setupEvents();
        
        // Cargar artículos
        this.loadArticles();
      }
    } catch (error) {
      console.error('Error al inicializar el gestor de artículos:', error);
      if (this.notificationManager) {
        this.notificationManager.error('Error al inicializar el gestor de artículos');
      }
    }
  }
  
  async render(container) {
    // Método completamente reescrito para evitar errores
    try {
      console.log('Inicializando gestor de artículos...');
      
      // Guardar referencia al contenedor
      this.container = container;
      
      // Crear la estructura del gestor de artículos (HTML simplificado para el debug)
      this.container.innerHTML = `
      <div class="article-manager">
        <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold">Artículos</h2>
          <button type="button" class="btn-primary new-article-btn">Nuevo artículo</button>
        </div>
        
        <div class="articles-list card mb-6">
          <div class="mb-4">
            <div class="flex flex-col md:flex-row gap-4 mb-4">
              <div class="flex-1">
                <div class="relative">
                  <input type="text" class="form-input pl-10 w-full" placeholder="Buscar artículos..." id="search-input">
                  <div class="absolute left-3 top-3 text-gray-400">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <circle cx="11" cy="11" r="8"></circle>
                      <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    </svg>
                  </div>
                </div>
              </div>
              <div class="w-full md:w-48">
                <select class="form-input w-full" id="category-filter">
                  <option value="">Todas las categorías</option>
                </select>
              </div>
              <div class="w-full md:w-48">
                <select class="form-input w-full" id="sort-filter">
                  <option value="pubDate-desc">Más recientes primero</option>
                </select>
              </div>
            </div>
          </div>
          
          <h3 class="text-lg font-semibold mb-4">Todos los artículos</h3>
          <div class="articles-container">
            <div class="loading">Cargando artículos...</div>
          </div>
          
          <div class="pagination-controls flex justify-between items-center mt-4 text-sm" style="display: none;">
            <div class="pagination-info text-gray-600">
              Mostrando <span class="current-range">1-10</span> de <span class="total-items">0</span> artículos
            </div>
            <div class="pagination-buttons flex space-x-2">
              <button class="px-3 py-1 border rounded hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed" id="prev-page" disabled>
                Anterior
              </button>
              <div class="page-numbers flex space-x-1"></div>
              <button class="px-3 py-1 border rounded hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed" id="next-page" disabled>
                Siguiente
              </button>
            </div>
          </div>
        </div>
        
        <div class="article-editor card hidden">
          <div class="flex justify-between items-center mb-4">
            <h3 class="text-lg font-semibold">Editor de artículo</h3>
            <button type="button" class="text-gray-500 hover:text-gray-700 back-to-list-btn">
              Volver a la lista
            </button>
          </div>
          
          <form class="article-form">
            <div class="form-group">
              <label for="article-title" class="form-label">Título</label>
              <input type="text" id="article-title" class="form-input" required>
            </div>
            
            <div class="form-group">
              <label for="article-description" class="form-label">Descripción</label>
              <textarea id="article-description" class="form-input" rows="2" required></textarea>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div class="form-group">
                <label for="article-category" class="form-label">Categoría</label>
                <select id="article-category" class="form-input" required>
                  <option value="">Seleccionar categoría</option>
                </select>
              </div>
              
              <div class="form-group">
                <label for="article-date" class="form-label">Fecha de publicación</label>
                <input type="date" id="article-date" class="form-input" required>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div class="form-group">
                <label for="article-slug" class="form-label">URL amigable (slug)</label>
                <input type="text" id="article-slug" class="form-input" required>
              </div>
              
              <div class="form-group">
                <label for="article-author" class="form-label">Autor</label>
                <select id="article-author" class="form-input">
                  <option value="">Sin autor asignado</option>
                </select>
              </div>
            </div>
            
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div class="form-group">
                <label for="article-tags" class="form-label">Etiquetas (separadas por coma)</label>
                <input type="text" id="article-tags" class="form-input" placeholder="agricultura, comunidad, sostenibilidad">
              </div>
            </div>
            
            <div class="form-group featured-image-container">
              <label class="form-label">Imagen destacada</label>
              <div class="flex space-x-2 mb-2">
                <button type="button" class="btn-secondary select-image-btn">Seleccionar imagen</button>
                <button type="button" class="btn-outline toggle-gallery-btn">Mostrar galería</button>
              </div>
              
              <div class="featured-image-preview border rounded-lg p-2 h-32 flex items-center justify-center bg-gray-50">
                <span class="text-gray-500">No hay imagen seleccionada</span>
              </div>
              
              <div class="image-gallery border rounded-lg p-2 mt-2 hidden">
                <div class="flex justify-between items-center mb-2">
                  <h4 class="text-sm font-semibold">Galería de imágenes</h4>
                  <button type="button" class="text-gray-500 hover:text-gray-700 close-gallery-btn">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                      <line x1="18" y1="6" x2="6" y2="18"></line>
                      <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                  </button>
                </div>
                <div class="gallery-grid grid grid-cols-4 gap-2 max-h-60 overflow-y-auto">
                  <div class="loading">Cargando imágenes...</div>
                </div>
              </div>
            </div>
            
            <div class="form-group">
              <label class="form-label">Contenido</label>
              <div class="editor-container" id="article-content-editor"></div>
            </div>
            
            <div class="flex justify-end mt-6">
              <button type="button" class="btn-secondary mr-2 cancel-btn">Cancelar</button>
              <button type="submit" class="btn-primary save-btn">Guardar artículo</button>
            </div>
          </form>
        </div>
      </div>
      `;
      
      console.log('Estructura del gestor de artículos creada');
      
      // Obtener referencias a los elementos
      this.articlesList = this.container.querySelector('.articles-list');
      this.articlesContainer = this.container.querySelector('.articles-container');
      this.articleEditor = this.container.querySelector('.article-editor');
      this.articleForm = this.container.querySelector('.article-form');
      this.editorContainer = this.container.querySelector('#article-content-editor');
      this.featuredImagePreview = this.container.querySelector('.featured-image-preview');
      this.featuredImageInput = this.container.querySelector('#article-image');
      this.galleryGrid = this.container.querySelector('.gallery-grid');
      
      console.log('Referencias a elementos obtenidas');
      
      // Configurar eventos
      this.setupEvents();
      console.log('Eventos configurados');
      
      // Cargar categorías para los filtros
      await this.loadCategories();
      console.log('Categorías cargadas');
      
      // Cargar artículos
      await this.loadArticles();
      console.log('Artículos cargados');
      
      // Configurar eventos para filtros y paginación
      this.setupFilterEvents();
      this.setupPaginationEvents();
      console.log('Eventos de filtros y paginación configurados');
      
      // Inicializar el editor de contenido si existe el contenedor
      const editorContainer = this.container.querySelector('.editor-container');
      if (editorContainer) {
        this.editorContainer = editorContainer;
        this.editor = new ContentEditor(this.editorContainer);
        console.log('Editor de contenido inicializado');
      }
      
      console.log('Renderizado del gestor de artículos completado');
    } catch (error) {
      console.error('Error en el método render:', error);
      if (this.notificationManager) {
        this.notificationManager.error('Error al cargar el gestor de artículos');
      }
      throw error; // Propagar el error
    }
  }
  
  setupEvents() {
    try {
      // Evento para crear un nuevo artículo
      const newArticleBtn = this.container.querySelector('.new-article-btn');
      if (newArticleBtn) {
        newArticleBtn.addEventListener('click', () => {
          this.showArticleEditor();
        });
      }
      
      // Evento para volver a la lista de artículos
      const backToListBtn = this.container.querySelector('.back-to-list-btn');
      if (backToListBtn) {
        backToListBtn.addEventListener('click', () => {
          this.showArticlesList();
        });
      }
      
      // Evento para cancelar la edición
      const cancelBtn = this.container.querySelector('.cancel-btn');
      if (cancelBtn) {
        cancelBtn.addEventListener('click', () => {
          this.showArticlesList();
        });
      }
      
      // Evento para seleccionar imagen destacada
      const selectImageBtn = this.container.querySelector('.select-image-btn');
      if (selectImageBtn) {
        selectImageBtn.addEventListener('click', () => {
          MediaLibrary.openModal((file) => {
            // Usar la URL pública si está disponible, de lo contrario usar la ruta
            const imagePath = file.publicUrl || file.path;
            
            // Actualizar la vista previa
            this.updateFeaturedImagePreview(imagePath);
            
            // Guardar la ruta de la imagen
            this.featuredImageInput.value = file.path;
          });
        });
      }
      
      // Evento para mostrar la galería de imágenes
      const toggleGalleryBtn = this.container.querySelector('.toggle-gallery-btn');
      if (toggleGalleryBtn) {
        toggleGalleryBtn.addEventListener('click', async () => {
          const gallery = this.container.querySelector('.image-gallery');
          const isHidden = gallery && gallery.classList.contains('hidden');
          
          if (isHidden) {
            // Si vamos a mostrar la galería, cargar las imágenes
            await this.loadGalleryImages();
            
            // Añadir evento de clic a las imágenes de la galería
            if (this.galleryGrid) {
              this.galleryGrid.addEventListener('click', (e) => {
                const galleryItem = e.target.closest('.gallery-item');
                if (!galleryItem) return;
                
                // Obtener la ruta de la imagen
                const imagePath = galleryItem.dataset.path;
                
                // Crear una instancia del gestor de medios para obtener la URL correcta
                const mediaManager = new MediaManager();
                
                // Extraer el ID de la imagen (sin el dominio) si es una URL completa
                let imageId = imagePath;
                if (imagePath.includes('https://')) {
                  // Si es una URL completa, extraer solo la parte de la ruta después del dominio
                  try {
                    const url = new URL(imagePath);
                    imageId = url.pathname.startsWith('/') ? url.pathname.substring(1) : url.pathname;
                  } catch (e) {
                    console.warn('URL inválida:', imagePath);
                  }
                }
              
                const imageUrl = mediaManager.getPublicUrl(imageId);
                
                // Actualizar la vista previa
                this.updateFeaturedImagePreview(imageUrl);
                
                // Guardar la ruta de la imagen
                this.featuredImageInput.value = imageId;
                
                // Cerrar la galería
                this.toggleImageGallery();
              });
            }
          }
          
          this.toggleImageGallery();
        });
      }
      
      // Evento para cerrar la galería de imágenes
      const closeGalleryBtn = this.container.querySelector('.close-gallery-btn');
      if (closeGalleryBtn) {
        closeGalleryBtn.addEventListener('click', () => {
          this.toggleImageGallery();
        });
      }
      
      // Evento para subir imagen
      const uploadImageInput = this.container.querySelector('.upload-image-input');
      if (uploadImageInput) {
        uploadImageInput.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (!file) return;
          
          try {
            // Mostrar indicador de carga
            if (this.featuredImagePreview) {
              this.featuredImagePreview.innerHTML = `
                <div class="flex flex-col items-center justify-center">
                  <div class="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-green-500 mb-2"></div>
                  <span class="text-gray-500">Subiendo imagen...</span>
                </div>
              `;
            }
            
            // Crear una instancia del gestor de medios
            const mediaManager = new MediaManager();
            
            // Subir el archivo
            const result = await mediaManager.uploadFile(file);
        
            // Actualizar la vista previa con la imagen subida
            this.updateFeaturedImagePreview(result.path);
            
            // Guardar la ruta de la imagen
            if (this.featuredImageInput) {
              this.featuredImageInput.value = result.path;
            }
            
            // Si la galería está visible, recargar las imágenes
            const gallery = this.container.querySelector('.image-gallery');
            if (gallery && !gallery.classList.contains('hidden')) {
              await this.loadGalleryImages();
            }
          } catch (error) {
            console.error('Error al subir imagen:', error);
            if (this.notificationManager) {
              this.notificationManager.error('Error al subir la imagen. Por favor, intenta de nuevo.');
            }
            this.resetFeaturedImagePreview();
          } finally {
            // Limpiar el input de archivo
            e.target.value = '';
          }
        });
      }
      
      // Evento para guardar el artículo
      if (this.articleForm) {
        this.articleForm.addEventListener('submit', async (e) => {
          e.preventDefault();
          
          try {
            // Obtener datos del formulario
            const articleData = {
              title: this.container.querySelector('#article-title').value,
              description: this.container.querySelector('#article-description').value,
              category: this.container.querySelector('#article-category').value,
              pubDate: this.formatDate(this.container.querySelector('#article-date').value),
              slug: this.container.querySelector('#article-slug').value,
              featured_image: this.featuredImageInput.value,
              content: this.editor.getContent(),
              author_id: this.container.querySelector('#article-author').value,
              tags: this.container.querySelector('#article-tags').value.split(',').map(tag => tag.trim())
            };
            
            // Validar datos
            if (!this.validateArticleData(articleData)) {
              return;
            }
            
            // Deshabilitar el botón de guardar
            const saveButton = this.container.querySelector('.save-btn');
            if (saveButton) {
              saveButton.disabled = true;
              saveButton.textContent = 'Guardando...';
            }
            
            // Crear o actualizar el artículo
            let result;
            if (this.currentArticle) {
              result = await this.contentManager.updateArticle(this.currentArticle.slug, articleData);
            } else {
              result = await this.contentManager.createArticle(articleData);
            }
            
            // Registrar la actividad
            await this.contentManager.logActivity({
              type: this.currentArticle ? 'edit' : 'create',
              entity_type: 'article',
              entity_id: articleData.slug,
              entity_title: articleData.title,
              user_name: 'Admin',
              details: {
                category: articleData.category,
                author_id: articleData.author_id
              }
            });
            
            // Mostrar notificación de éxito
            if (this.notificationManager) {
              this.notificationManager.success(
                this.currentArticle 
                  ? 'Artículo actualizado correctamente' 
                  : 'Artículo creado correctamente'
              );
            }
            
            // Recargar la lista de artículos y volver a la lista
            await this.loadArticles();
            this.showArticlesList();
            
          } catch (error) {
            console.error('Error al guardar artículo:', error);
            if (this.notificationManager) {
              this.notificationManager.error('Error al guardar el artículo. Por favor, intenta de nuevo.');
            }
          } finally {
            // Habilitar nuevamente el botón de guardar
            const saveButton = this.container.querySelector('.save-btn');
            if (saveButton) {
              saveButton.disabled = false;
              saveButton.textContent = 'Guardar artículo';
            }
          }
        });
      }
      
      // Evento para generar slug automáticamente a partir del título
      const titleInput = this.container.querySelector('#article-title');
      const slugInput = this.container.querySelector('#article-slug');
      
      if (titleInput && slugInput) {
        titleInput.addEventListener('input', (e) => {
          // Solo generar slug automáticamente si el campo está vacío o no ha sido modificado manualmente
          if (!slugInput.dataset.modified) {
            slugInput.value = this.generateSlug(e.target.value);
          }
        });
        
        // Marcar el campo de slug como modificado manualmente
        slugInput.addEventListener('input', (e) => {
          e.target.dataset.modified = 'true';
        });
      }
      
    } catch (error) {
      console.error('Error al configurar eventos:', error);
      if (this.notificationManager) {
        this.notificationManager.error('Error al configurar eventos del gestor de artículos');
      }
    }
  }
  
  async loadCategories() {
    try {
      // Obtener categorías desde la API
      const categories = await this.contentManager.getCategories();
      
      // Obtener el elemento select para el filtro de categorías
      const categoryFilter = this.container.querySelector('#category-filter');
      const articleCategorySelect = this.container.querySelector('#article-category');
      
      if (categories && categories.length > 0) {
        // Crear opciones para el filtro de categorías
        const categoryOptions = categories.map(category => `
          <option value="${category.slug}">${category.name}</option>
        `).join('');
        
        // Actualizar el filtro de categorías
        if (categoryFilter) {
          // Mantener la opción "Todas las categorías"
          categoryFilter.innerHTML = `
            <option value="">Todas las categorías</option>
            ${categoryOptions}
          `;
        }
        
        // Actualizar también el selector de categorías en el formulario de edición
        if (articleCategorySelect) {
          // Mantener la opción "Seleccionar categoría"
          articleCategorySelect.innerHTML = `
            <option value="">Seleccionar categoría</option>
            ${categoryOptions}
          `;
        }
      }
    } catch (error) {
      console.error('Error al cargar categorías:', error);
      // No mostrar error al usuario, simplemente mantener las categorías predeterminadas
    }
  }
  
  setupFilterEvents() {
    // Evento para el campo de búsqueda
    const searchInput = this.container.querySelector('#search-input');
    if (searchInput) {
      // Usar debounce para evitar muchas llamadas mientras el usuario escribe
      let debounceTimeout;
      searchInput.addEventListener('input', (e) => {
        clearTimeout(debounceTimeout);
        debounceTimeout = setTimeout(() => {
          this.filters.search = e.target.value.trim();
          this.pagination.page = 1; // Volver a la primera página al cambiar el filtro
          this.loadArticles();
        }, 300);
      });
    }
    
    // Evento para el filtro de categoría
    const categoryFilter = this.container.querySelector('#category-filter');
    if (categoryFilter) {
      categoryFilter.addEventListener('change', (e) => {
        this.filters.category = e.target.value;
        this.pagination.page = 1; // Volver a la primera página al cambiar el filtro
        this.loadArticles();
      });
    }
    
    // Evento para el filtro de ordenación
    const sortFilter = this.container.querySelector('#sort-filter');
    if (sortFilter) {
      sortFilter.addEventListener('change', (e) => {
        const [sortBy, sortOrder] = e.target.value.split('-');
        this.filters.sortBy = sortBy;
        this.filters.sortOrder = sortOrder;
        this.loadArticles();
      });
    }
  }
  
  setupPaginationEvents() {
    // Evento para el botón de página anterior
    const prevPageBtn = this.container.querySelector('#prev-page');
    if (prevPageBtn) {
      prevPageBtn.addEventListener('click', () => {
        if (this.pagination.page > 1) {
          this.pagination.page--;
          this.loadArticles();
        }
      });
    }
    
    // Evento para el botón de página siguiente
    const nextPageBtn = this.container.querySelector('#next-page');
    if (nextPageBtn) {
      nextPageBtn.addEventListener('click', () => {
        if (this.pagination.page < this.pagination.totalPages) {
          this.pagination.page++;
          this.loadArticles();
        }
      });
    }
  }
  
  async loadArticles() {
    try {
      // Mostrar indicador de carga
      this.articlesContainer.innerHTML = `<div class="loading">Cargando artículos...</div>`;
      
      // Preparar parámetros para la API
      const params = {
        page: this.pagination.page,
        limit: this.pagination.limit,
        sortBy: this.filters.sortBy,
        sortOrder: this.filters.sortOrder
      };
      
      // Añadir filtros si están presentes
      if (this.filters.search) {
        params.search = this.filters.search;
      }
      
      if (this.filters.category) {
        params.category = this.filters.category;
      }
      
      // Obtener artículos con paginación y filtros
      const response = await this.contentManager.getArticles(params);
      
      // Actualizar información de paginación
      if (response.pagination) {
        this.pagination.total = response.pagination.total || 0;
        this.pagination.totalPages = response.pagination.totalPages || 1;
      } else {
        // Si la API no devuelve información de paginación, calcularla aproximadamente
        this.pagination.total = response.articles ? response.articles.length : 0;
        this.pagination.totalPages = 1;
      }
      
      // Actualizar controles de paginación
      this.updatePaginationControls();
      
      // Renderizar artículos
      const articles = response.articles || response;
      this.renderArticles(articles);
    } catch (error) {
      console.error('Error al cargar artículos:', error);
      this.articlesContainer.innerHTML = `<div class="error">Error al cargar artículos. <button class="text-blue-500 hover:underline">Reintentar</button></div>`;
      
      // Configurar evento para reintentar
      this.articlesContainer.querySelector('button').addEventListener('click', () => {
        this.loadArticles();
      });
    }
  }
  
  updatePaginationControls() {
    const paginationControls = this.container.querySelector('.pagination-controls');
    const totalItemsSpan = this.container.querySelector('.total-items');
    const currentRangeSpan = this.container.querySelector('.current-range');
    const pageNumbersDiv = this.container.querySelector('.page-numbers');
    const prevPageBtn = this.container.querySelector('#prev-page');
    const nextPageBtn = this.container.querySelector('#next-page');
    
    // Mostrar controles de paginación solo si hay más de una página
    if (this.pagination.totalPages <= 1) {
      paginationControls.style.display = 'none';
      return;
    }
    
    // Mostrar controles de paginación
    paginationControls.style.display = 'flex';
    
    // Actualizar información de paginación
    totalItemsSpan.textContent = this.pagination.total;
    
    const startItem = (this.pagination.page - 1) * this.pagination.limit + 1;
    const endItem = Math.min(startItem + this.pagination.limit - 1, this.pagination.total);
    currentRangeSpan.textContent = `${startItem}-${endItem}`;
    
    // Actualizar estado de los botones de navegación
    prevPageBtn.disabled = this.pagination.page <= 1;
    nextPageBtn.disabled = this.pagination.page >= this.pagination.totalPages;
    
    // Generar botones de página
    pageNumbersDiv.innerHTML = '';
    
    // Determinar qué páginas mostrar
    let startPage = Math.max(1, this.pagination.page - 2);
    let endPage = Math.min(this.pagination.totalPages, startPage + 4);
    
    // Ajustar si estamos cerca del final
    if (endPage - startPage < 4) {
      startPage = Math.max(1, endPage - 4);
    }
    
    // Crear botones para cada página
    for (let i = startPage; i <= endPage; i++) {
      const pageButton = document.createElement('button');
      pageButton.className = `px-3 py-1 border rounded ${
        i === this.pagination.page 
          ? 'bg-blue-500 text-white' 
          : 'hover:bg-gray-100'
      }`;
      pageButton.textContent = i;
      pageButton.addEventListener('click', () => {
        this.pagination.page = i;
        this.loadArticles();
      });
      pageNumbersDiv.appendChild(pageButton);
    }
  }
  
  renderArticles(articles) {
    if (articles.length === 0) {
      this.articlesContainer.innerHTML = `
        <div class="empty-state bg-gray-50 p-8 text-center rounded-lg border border-gray-200">
          <p class="text-gray-600 mb-4">No se encontraron artículos con los filtros actuales.</p>
          <button id="clear-filters-btn" class="text-blue-500 hover:text-blue-700 underline">
            Limpiar filtros
          </button>
        </div>
      `;
      
      // Configurar evento para limpiar filtros
      const clearFiltersBtn = this.articlesContainer.querySelector('#clear-filters-btn');
      if (clearFiltersBtn) {
        clearFiltersBtn.addEventListener('click', () => {
          // Resetear filtros
          this.filters.search = '';
          this.filters.category = '';
          this.filters.sortBy = 'pubDate';
          this.filters.sortOrder = 'desc';
          
          // Resetear controles de UI
          const searchInput = this.container.querySelector('#search-input');
          if (searchInput) searchInput.value = '';
          
          const categoryFilter = this.container.querySelector('#category-filter');
          if (categoryFilter) categoryFilter.value = '';
          
          const sortFilter = this.container.querySelector('#sort-filter');
          if (sortFilter) sortFilter.value = 'pubDate-desc';
          
          // Volver a la primera página
          this.pagination.page = 1;
          
          // Recargar artículos
          this.loadArticles();
        });
      }
      
      return;
    }
    
    // Crear tabla de artículos
    const tableHTML = `
      <table class="min-w-full bg-white border border-gray-200 rounded-lg overflow-hidden">
        <thead class="bg-gray-50">
          <tr>
            <th class="px-4 py-3 border-b text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Título</th>
            <th class="px-4 py-3 border-b text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Slug</th>
            <th class="px-4 py-3 border-b text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoría</th>
            <th class="px-4 py-3 border-b text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Fecha</th>
            <th class="px-4 py-3 border-b text-center text-xs font-medium text-gray-500 uppercase tracking-wider">Acciones</th>
          </tr>
        </thead>
        <tbody class="divide-y divide-gray-200">
          ${articles.map(article => `
            <tr data-slug="${article.slug}" class="hover:bg-gray-50">
              <td class="px-4 py-3 border-b">
                <div class="text-sm font-medium text-gray-900">${article.title || 'Sin título'}</div>
              </td>
              <td class="px-4 py-3 border-b">
                <div class="text-sm text-gray-500">${article.slug || 'sin-slug'}</div>
              </td>
              <td class="px-4 py-3 border-b">
                <span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-green-100 text-green-800">
                  ${article.category || 'Sin categoría'}
                </span>
              </td>
              <td class="px-4 py-3 border-b">
                <div class="text-sm text-gray-500">${this.formatDate(article.pubDate)}</div>
              </td>
              <td class="px-4 py-3 border-b text-center">
                <button class="edit-btn text-blue-500 hover:text-blue-700 mr-2 text-sm font-medium">
                  Editar
                </button>
                <button class="delete-btn text-red-500 hover:text-red-700 text-sm font-medium">
                  Eliminar
                </button>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;
    
    this.articlesContainer.innerHTML = tableHTML;
    
    // Configurar eventos para los botones de editar y eliminar
    this.articlesContainer.querySelectorAll('.edit-btn').forEach(button => {
      button.addEventListener('click', (event) => {
        const slug = event.target.closest('tr').dataset.slug;
        this.editArticle(slug);
      });
    });
    
    this.articlesContainer.querySelectorAll('.delete-btn').forEach(button => {
      button.addEventListener('click', (event) => {
        const slug = event.target.closest('tr').dataset.slug;
        this.deleteArticle(slug);
      });
    });
    
    // Actualizar controles de paginación
    this.updatePaginationControls();
  }
  
  async editArticle(slug) {
    console.log(`Iniciando edición del artículo con slug: ${slug}`);
    this.showLoading('Cargando artículo...');
    
    try {
      // 1. Obtener el artículo de la API
      const response = await this.contentManager.getArticle(slug);
      console.log('Artículo recibido de la API:', response);
      
      // La respuesta puede venir en diferentes formatos, manejar ambos casos
      const article = response.article || response;
      console.log('Datos del artículo procesados:', article);
      
      if (!article) {
        throw new Error('Artículo no encontrado');
      }
      
      // 2. Mostrar el editor y configurar la interfaz básica
      this.showArticleEditor();
      this.currentArticle = article;
      this.setupEditorInterface();
      
      // 3. Cargar los datos del artículo en el formulario (separamos la lógica para evitar anidamiento)
      this.loadArticleDataIntoForm(article);
      
    } catch (error) {
      console.error('Error al cargar artículo:', error);
      if (this.notificationManager) {
        this.notificationManager.error('Error al cargar el artículo: ' + (error.message || 'Error desconocido'));
      }
      this.hideLoading();
    }
  }
  
  setupEditorInterface() {
    try {
      // Actualizar título del editor
      const editorTitle = this.container.querySelector('.article-editor h3');
      if (editorTitle) {
        editorTitle.textContent = 'Editar artículo';
      }
      
      // Asegurarse de que el botón para volver al listado funcione
      const backButton = this.container.querySelector('.back-to-list-btn');
      if (backButton) {
        // Eliminar eventos anteriores para evitar duplicados
        const newBackButton = backButton.cloneNode(true);
        backButton.parentNode.replaceChild(newBackButton, backButton);
        
        // Agregar evento para volver al listado
        newBackButton.addEventListener('click', () => {
          this.showArticlesList();
        });
      }
      
      // Imprimir la estructura del formulario para depuración
      console.log('Estructura del formulario:', {
        articleEditor: this.container.querySelector('.article-editor') ? 'Encontrado' : 'No encontrado',
        articleForm: this.container.querySelector('.article-form') ? 'Encontrado' : 'No encontrado',
        titleInput: this.container.querySelector('#article-title') ? 'Encontrado' : 'No encontrado',
        descriptionInput: this.container.querySelector('#article-description') ? 'Encontrado' : 'No encontrado',
        categorySelect: this.container.querySelector('#article-category') ? 'Encontrado' : 'No encontrado',
        dateInput: this.container.querySelector('#article-date') ? 'Encontrado' : 'No encontrado',
        slugInput: this.container.querySelector('#article-slug') ? 'Encontrado' : 'No encontrado',
        featuredImagePreview: this.container.querySelector('.featured-image-preview') ? 'Encontrado' : 'No encontrado',
      });
    } catch (error) {
      console.error('Error al configurar interfaz del editor:', error);
    }
  }
  
  loadArticleDataIntoForm(article) {
    if (!article) return;
    
    try {
      // Cargar los datos del artículo en el formulario
      const titleInput = this.container.querySelector('#article-title');
      const descriptionInput = this.container.querySelector('#article-description');
      const categorySelect = this.container.querySelector('#article-category');
      const dateInput = this.container.querySelector('#article-date');
      const slugInput = this.container.querySelector('#article-slug');
      const authorSelect = this.container.querySelector('#article-author');
      const tagsInput = this.container.querySelector('#article-tags');
      
      // Verificar que todos los elementos existan
      if (!titleInput || !descriptionInput || !categorySelect || !dateInput || !slugInput) {
        console.error('No se encontraron todos los elementos del formulario');
        if (this.notificationManager) {
          this.notificationManager.error('Error al cargar el formulario');
        }
        this.hideLoading();
        return;
      }
      
      // Asignar valores con comprobación de nulos
      titleInput.value = article.title || '';
      descriptionInput.value = article.description || '';
      categorySelect.value = article.category || '';
      slugInput.value = article.slug || '';
      slugInput.dataset.edited = 'true';
      
      // Formatear la fecha para el input date
      this.setDateInputValue(dateInput, article.pubDate);
      
      // Seleccionar el autor si existe
      if (authorSelect) {
        authorSelect.value = article.author_id || '';
      }
      
      // Cargar etiquetas
      if (tagsInput) {
        tagsInput.value = Array.isArray(article.tags) ? article.tags.join(', ') : '';
      }
      
      // Cargar imagen destacada
      this.loadFeaturedImage(article.featured_image);
      
      // Cargar contenido en el editor (en un método separado para evitar anidamiento)
      setTimeout(() => this.initializeEditor(article.content || ''), 500);
      
    } catch (error) {
      console.error('Error al cargar datos en el formulario:', error);
      if (this.notificationManager) {
        this.notificationManager.error('Error al cargar los datos del artículo');
      }
      this.hideLoading();
    }
  }
  
  setDateInputValue(dateInput, pubDate) {
    try {
      if (pubDate) {
        const date = new Date(pubDate);
        if (!isNaN(date.getTime())) {
          dateInput.value = date.toISOString().split('T')[0];
        } else {
          dateInput.value = new Date().toISOString().split('T')[0];
          console.warn('Fecha inválida en el artículo:', pubDate);
        }
      } else {
        dateInput.value = new Date().toISOString().split('T')[0];
      }
    } catch (error) {
      console.error('Error al procesar fecha:', error);
      dateInput.value = new Date().toISOString().split('T')[0];
    }
  }
  
  loadFeaturedImage(featuredImage) {
    try {
      const featuredImagePreview = this.container.querySelector('.featured-image-preview');
      if (!featuredImagePreview) return;
      
      // Verificar si existe el input para la imagen destacada
      let featuredImageInput = this.container.querySelector('#article-image');
      if (!featuredImageInput) {
        featuredImageInput = this.container.querySelector('#article-featured-image');
      }
      
      // Si no existe el input, intentamos encontrar el contenedor y lo creamos
      if (!featuredImageInput) {
        const featuredImageContainer = this.container.querySelector('.featured-image-container');
        if (featuredImageContainer) {
          featuredImageInput = document.createElement('input');
          featuredImageInput.type = 'hidden';
          featuredImageInput.id = 'article-featured-image';
          featuredImageInput.name = 'featured_image';
          featuredImageContainer.appendChild(featuredImageInput);
        }
      }
      
      if (featuredImage && featuredImagePreview) {
        // Actualizar la vista previa de la imagen
        this.updateFeaturedImagePreview(featuredImage, featuredImagePreview);
        
        // Actualizar el valor del input oculto si existe
        if (featuredImageInput) {
          featuredImageInput.value = featuredImage;
        }
      } else if (featuredImagePreview) {
        // Resetear la vista previa
        featuredImagePreview.innerHTML = `<span class="text-gray-500">No hay imagen seleccionada</span>`;
        
        // Limpiar el input oculto si existe
        if (featuredImageInput) {
          featuredImageInput.value = '';
        }
      }
    } catch (error) {
      console.error('Error al cargar imagen destacada:', error);
    }
  }
  
  initializeEditor(content) {
    try {
      // Verificar si existe el contenedor del editor
      const editorContainer = this.container.querySelector('.editor-container');
      if (!editorContainer) {
        console.error('No se encontró el contenedor del editor');
        this.hideLoading();
        return;
      }
      
      // Intentar inicializar el editor
      this.editor = new ContentEditor(editorContainer);
      
      // Esperar a que el editor esté listo y establecer el contenido
      setTimeout(() => {
        try {
          if (this.editor && typeof this.editor.setContent === 'function') {
            this.editor.setContent(content);
            console.log('Contenido establecido en el editor correctamente');
          } else {
            console.error('El editor no tiene el método setContent o no está correctamente inicializado');
          }
        } catch (error) {
          console.error('Error al establecer contenido en el editor:', error);
        } finally {
          this.hideLoading();
        }
      }, 1000);
      
    } catch (error) {
      console.error('Error al inicializar editor:', error);
      if (this.notificationManager) {
        this.notificationManager.error('Error al inicializar el editor');
      }
      this.hideLoading();
    }
  }

  updateFeaturedImagePreview(imagePath, previewElement) {
    console.log('Actualizando vista previa de imagen destacada:', imagePath);
    
    // Si no hay ruta de imagen o elemento de vista previa, salir
    if (!imagePath || !previewElement) {
      if (previewElement) {
        previewElement.innerHTML = `<span class="text-gray-500">No hay imagen seleccionada</span>`;
      }
      return;
    }
    
    // Usar el gestor de medios para obtener la URL correcta si está disponible
    let imageUrl = imagePath;
    
    try {
      if (this.mediaManager) {
        imageUrl = this.mediaManager.getPublicUrl(imagePath);
        console.log('URL pública generada:', imageUrl);
      } else if (!imagePath.startsWith('http') && !imagePath.startsWith('/')) {
        // Construir URL relativa si es necesario
        imageUrl = `/${imagePath}`;
      }
    } catch (error) {
      console.error('Error al generar URL de imagen:', error);
      // Usar la ruta original en caso de error
      if (!imagePath.startsWith('http') && !imagePath.startsWith('/')) {
        imageUrl = `/${imagePath}`;
      }
    }
    
    // Actualizar la vista previa
    previewElement.innerHTML = `
      <img src="${imageUrl}" alt="Vista previa" class="max-h-full max-w-full object-contain">
    `;
  }
  
  showArticlesList() {
    console.log('Volviendo a la lista de artículos');
    
    // Ocultar el editor de artículos
    const articleEditor = this.container.querySelector('.article-editor');
    if (articleEditor) {
      articleEditor.classList.add('hidden');
    }
    
    // Mostrar la lista de artículos
    const articlesList = this.container.querySelector('.articles-list');
    if (articlesList) {
      articlesList.classList.remove('hidden');
    }
    
    // Limpiar el artículo actual
    this.currentArticle = null;
    
    // Recargar la lista de artículos para mostrar cambios recientes
    this.loadArticles();
  }
  
  showArticleEditor() {
    // Ocultar la lista de artículos
    const articlesList = this.container.querySelector('.articles-list');
    if (articlesList) {
      articlesList.classList.add('hidden');
    }
    
    // Mostrar el editor de artículos
    const articleEditor = this.container.querySelector('.article-editor');
    if (articleEditor) {
      articleEditor.classList.remove('hidden');
    }
  }

  // Método para mostrar un indicador de carga
  showLoading(message = 'Cargando...') {
    // Crear el elemento de carga si no existe
    let loadingElement = this.container.querySelector('.loading-overlay');
    
    if (!loadingElement) {
      loadingElement = document.createElement('div');
      loadingElement.className = 'loading-overlay fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      this.container.appendChild(loadingElement);
    }
    
    // Actualizar el mensaje de carga
    loadingElement.innerHTML = `
      <div class="bg-white p-4 rounded-lg shadow-lg text-center">
        <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-green-500 mx-auto mb-2"></div>
        <p>${message}</p>
      </div>
    `;
    
    // Mostrar el indicador de carga
    loadingElement.style.display = 'flex';
  }
  
  // Método para ocultar el indicador de carga
  hideLoading() {
    const loadingElement = this.container.querySelector('.loading-overlay');
    if (loadingElement) {
      loadingElement.style.display = 'none';
    }
  }
  
  // Método para resetear la vista previa de la imagen destacada
  resetFeaturedImagePreview() {
    const featuredImagePreview = this.container.querySelector('.featured-image-preview');
    if (featuredImagePreview) {
      featuredImagePreview.innerHTML = `<span class="text-gray-500">No hay imagen seleccionada</span>`;
    }
  }

  resetFeaturedImagePreview() {
    this.featuredImagePreview.innerHTML = `
      <div class="flex flex-col items-center justify-center h-full">
        <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1" stroke-linecap="round" stroke-linejoin="round" class="text-gray-300 mb-2">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <circle cx="8.5" cy="8.5" r="1.5"></circle>
          <polyline points="21 15 16 10 5 21"></polyline>
        </svg>
        <span class="text-gray-500">No hay imagen seleccionada</span>
      </div>
    `;
    this.featuredImageInput.value = '';
  }
  
  async deleteArticle(slug) {
    try {
      if (!confirm('¿Estás seguro de que deseas eliminar este artículo? Esta acción no se puede deshacer.')) {
        return;
      }
      
      this.showLoading('Eliminando artículo...');
      
      // Obtener el título del artículo antes de eliminarlo
      const article = this.articles.find(a => a.slug === slug);
      const articleTitle = article ? article.title : 'Artículo desconocido';
      const articleCategory = article ? article.category : '';
      
      // Eliminar el artículo
      const result = await this.contentManager.deleteArticle(slug);
      
      if (result.error) {
        throw new Error(result.error);
      }
      
      // Registrar la actividad
      await this.contentManager.logActivity({
        type: 'delete',
        entity_type: 'article',
        entity_id: slug,
        entity_title: articleTitle,
        user_name: 'Admin',
        details: {
          category: articleCategory
        }
      });
      
      notifications.success('Artículo eliminado correctamente');
      
      // Recargar la lista de artículos
      await this.loadArticles();
      
      this.hideLoading();
    } catch (error) {
      console.error('Error al eliminar artículo:', error);
      this.hideLoading();
      notifications.error('Error al eliminar el artículo: ' + error.message);
    }
  }
  
  showArticlesList() {
    this.articlesList.classList.remove('hidden');
    this.articleEditor.classList.add('hidden');
    this.currentArticle = null;
  }
  
  showArticleEditor() {
    this.articlesList.classList.add('hidden');
    this.articleEditor.classList.remove('hidden');
    
    // Si es un nuevo artículo, limpiar el formulario
    if (!this.currentArticle) {
      this.articleForm.reset();
      this.container.querySelector('#article-slug').dataset.modified = '';
      this.resetFeaturedImagePreview();
      
      // Establecer la fecha actual
      const today = new Date();
      const formattedDate = today.toISOString().split('T')[0];
      this.container.querySelector('#article-date').value = formattedDate;
      
      // Limpiar el editor
      if (this.editor) {
        this.editor.setContent('');
      }
    }
  }
  
  validateArticleData(articleData) {
    // Validar campos requeridos
    const requiredFields = ['title', 'description', 'category', 'pubDate', 'slug'];
    for (const field of requiredFields) {
      if (!articleData[field]) {
        notifications.error(`El campo "${field}" es obligatorio`);
        return false;
      }
    }
    
    // Validar formato del slug
    const slugRegex = /^[a-z0-9]+(?:-[a-z0-9]+)*$/;
    if (!slugRegex.test(articleData.slug)) {
      notifications.error('El slug debe contener solo letras minúsculas, números y guiones');
      return false;
    }
    
    return true;
  }
  
  // Utilidades para formatear fechas
  formatDate(dateString) {
    if (!dateString) return '';
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) return '';
      const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      return `${months[date.getMonth()]} ${date.getDate()} ${date.getFullYear()}`;
    } catch (error) {
      console.error('Error al formatear fecha:', error, dateString);
      return '';
    }
  }
  
  formatDateShort(dateString) {
    if (!dateString) return '';
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) return '';
      
      // Usar formato español
      const options = { day: '2-digit', month: 'short', year: 'numeric' };
      return date.toLocaleDateString('es-ES', options);
    } catch (error) {
      console.error('Error al formatear fecha corta:', error, dateString);
      return '';
    }
  }
  
  formatDateForInput(dateString) {
    if (!dateString) return '';
    try {
      const date = new Date(dateString);
      if (isNaN(date.getTime())) return '';
      
      // Formato YYYY-MM-DD para inputs de tipo date
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      return `${year}-${month}-${day}`;
    } catch (error) {
      console.error('Error al formatear fecha para input:', error, dateString);
      return '';
    }
  }
  
  // Utilidad para generar slug a partir del título
  generateSlug(title) {
    return title
      .toLowerCase()
      .replace(/[^\w\s-]/g, '') // Eliminar caracteres especiales
      .replace(/\s+/g, '-') // Reemplazar espacios por guiones
      .replace(/-+/g, '-') // Eliminar guiones duplicados
      .trim(); // Eliminar espacios al inicio y al final
  }
  
  // Utilidad para obtener el nombre de la categoría
  getCategoryName(categoryId) {
    const categories = {
      'agricultura': 'Agricultura',
      'comunidad': 'Comunidad',
      'sostenibilidad': 'Sostenibilidad',
      'politica-agraria': 'Política Agraria',
      'tecnologia-rural': 'Tecnología Rural',
      'cultura': 'Cultura',
      'eventos': 'Eventos'
    };
    
    return categories[categoryId] || categoryId;
  }
  
  toggleImageGallery() {
    const gallery = this.container.querySelector('.image-gallery');
    gallery.classList.toggle('hidden');
  }
  
  // Cargar imágenes para la galería
  async loadGalleryImages() {
    try {
      // Mostrar indicador de carga
      this.galleryGrid.innerHTML = `<div class="loading col-span-4 text-center py-4">Cargando imágenes...</div>`;
      
      // Crear una instancia del gestor de medios
      const mediaManager = new MediaManager();
      
      // Obtener los archivos de medios
      const mediaFiles = await mediaManager.getMediaFiles();
      
      // Filtrar solo imágenes
      const imageFiles = mediaFiles.filter(file => 
        file.type.startsWith('image/') || 
        file.path.match(/\.(jpg|jpeg|png|gif|webp)$/i)
      );
      
      // Renderizar la galería
      if (imageFiles.length === 0) {
        this.galleryGrid.innerHTML = `<div class="col-span-4 text-center py-4 text-gray-500">No hay imágenes disponibles</div>`;
        return;
      }
      
      // Crear elementos para cada imagen
      this.galleryGrid.innerHTML = imageFiles.map(file => {
        // Usar el MediaManager para generar la URL correcta de la imagen
        // Usar file.id en lugar de file.path para evitar duplicación de dominio
        const imageUrl = file.id ? mediaManager.getPublicUrl(file.id) : file.path;
        
        return `
        <div class="gallery-item cursor-pointer border rounded-lg overflow-hidden hover:border-blue-500 transition-colors" data-path="${file.path}">
          <div class="aspect-square bg-gray-100 flex items-center justify-center overflow-hidden">
            <img src="${imageUrl}" alt="${file.name}" class="w-full h-full object-cover">
          </div>
          <div class="p-1 text-xs truncate text-center">${file.name}</div>
        </div>
      `}).join('');
    } catch (error) {
      console.error('Error al cargar imágenes:', error);
      this.galleryGrid.innerHTML = `<div class="col-span-4 text-center py-4 text-red-500">Error al cargar imágenes</div>`;
    }
  }
  
  // Cargar autores para el selector
  async loadAuthors() {
    try {
      const authors = await this.contentManager.getAuthors();
      const authorSelect = this.container.querySelector('#article-author');
      
      // Mantener la opción "Sin autor asignado"
      authorSelect.innerHTML = '<option value="">Sin autor asignado</option>';
      
      // Añadir los autores al selector
      if (authors && authors.length > 0) {
        authors.forEach(author => {
          const option = document.createElement('option');
          option.value = author.id;
          option.textContent = author.name;
          authorSelect.appendChild(option);
        });
      }
    } catch (error) {
      console.error('Error al cargar autores:', error);
      notifications.error('No se pudieron cargar los autores');
    }
  }
  
  // Método para mostrar indicador de carga
  showLoading(message = 'Cargando...') {
    // Crear notificación de carga
    this.loadingNotification = notifications.info(message, 0);
  }
  
  // Método para ocultar indicador de carga
  hideLoading() {
    // Cerrar notificación de carga si existe
    if (this.loadingNotification) {
      notifications.close(this.loadingNotification);
      this.loadingNotification = null;
    }
  }
}
